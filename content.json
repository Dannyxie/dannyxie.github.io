[{"title":"webpack入门","date":"2016-03-10T14:34:59.000Z","path":"2016/03/10/webpack入门/","text":"##什么是webpackwebpack是一个module bundler，可以将把有依赖关系的各种文件打包成一系列的静态资源 ##安装首先我们安装最新版的webpack, 我安装的版本是2.2.11npm install -g webpack 下面我们将探讨webpack 2 的使用 我们可以直接在终端中使用webpack，命令如下123webpack &#123;源文件／入口文件&#125; &#123;目标文件&#125;webpack --watch //监听模式webpack -p //混淆脚本 考虑到随着我们项目复杂度的增高，有可能我们的配置选项也会很多，所以，我们完全可以将配置放到文件中, webpack在执行的时候默认会加载webpack.config.js文件作为配置, 如果我们需要指定配置文件的话，方法如下:1webpack --config &#123;配置文件&#125; 下面我们来创建一个简单的项目我们的项目结构如下123456.├── dist├── src│ └── entry.js├── index.html└── webpack.config.js index.html123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src/entry.js1document.write(&apos;hello world&apos;) webpack.config.js123456789const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 在终端下运行命令:1webpack --watch 使用http-server起一个本地服务1http-server -p 8080 可以看到，entry.js的内容被打包到了bundle.js 中这是webpack最简单的应用，下面我们来看看如何使用loader ##loaderwebpack2中已经集成了json-loader, 所以我们无需安装其他的依赖在src中增加hello.json文件1&#123;\"greet\" : \"hello from json\"&#125; 修改entry.js12import json from './hello.json'document.write(json.greet) 刷新http://127.0.0.1:8080/可以看到hello.json的结果已经输出到浏览器中 ####使用其他loader如果其他格式的文件，比如css文件我们可以使用相应的loader来解析,安装依赖1npm install --save-dev style-loader css-loader 修改webpack.config.js123456789101112131415const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;] &#125;] &#125;&#125; entry.js123import &apos;./main.css&apos;import json from &apos;./hello.json&apos;document.write(json.greet) 可以看到，main.css也经过loader的解析而打包进bundle.js里面了","tags":[]},{"title":"浅谈javascript的原型及原型链","date":"2016-03-08T14:26:51.000Z","path":"2016/03/08/浅谈javascript的原型及原型链/","text":"原型与原型链是javascript里面最最核心的内容，如果不能理解它们之间的存在关系的话，那么我们是不能理解这门语言的。 在JS中，主要有两种创建对象的方法, 分别是对象字面量以及调用构造函数12345//对象字面量var obj1 = &#123;&#125;//调用构造函数var obj2 = new Object() 其实上述两种创建对象的方法，本质上是一样的，都是JS引擎调用对象的构造函数来新建出一个对象。构造函数本身也是一个普通的JS函数 下面我们来看一个例子1234567891011121314151617181920212223//创建构造函数function Person(name)&#123; this.name = name&#125;//每个构造函数JS引擎都会自动添加一个prototype属性，我们称之为原型，这是一个对象//每个由构造函数创建的对象都会共享prototype上面的属性与方法console.log(typeof Person.prototype) // 'object'//我们为Person.prototype添加sayName方法Person.prototype.sayName = function()&#123; console.log(this.name)&#125;//创建实例var person1 = new Person('Messi')var person2 = new Person('Suarez')person1.sayName() // 'Messi'person2.sayName() // 'Suarez'person1.sayName === person2.sayName //true 我们借助上面的例子来理解构造函数-原型-实例，三者之间的关系，主要有几个基本概念 构造函数默认会有一个protoype属性指向它的原型 构造函数的原型会有一个consctructor的属性指向构造函数本身, 即 1Person.prototype.constructor === Person 每一个new出来的实例都有一个隐式的__proto__属性，指向它们的构造函数的原型，即 12person1.__proto__ === Person.prototypeperson1.__proto__.constructor === Person 了解了这些基本概念之后，我们再来看看javascript的一些原生构造函数的关系网，看下列的图 引自stackoverflow 按照我们上面的理解, Oject本身是一个构造函数，它也是一个对象，那么 1Object.__proto__ === Function.prototype 为了方便我们记住上图，还有几个需要我们知道的特殊概念： Function的原型属性与Function的原型指向同一个对象. 即 1Function.__proto__ == Function.prototype Object.prototype.__proto__ === null typeof Function.prototype === &#39;function&#39;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"prototype","slug":"prototype","permalink":"http://yoursite.com/tags/prototype/"}]}]