[{"title":"关于点击鼠标右键在firefox上面的坑","date":"2017-05-10T07:44:59.000Z","path":"2017/05/10/关于点击鼠标右键在firefox上面的坑/","text":"","tags":[]},{"title":"使用rollup","date":"2017-04-30T17:32:32.000Z","path":"2017/05/01/使用rollup/","text":"Rollup被誉为下一代ES 安装1$ npm install --global rollup 使用watch模式安装依赖rollup-watch后，便可以愉快地开发啦1$npm install --save-dev rollup-watch 启用模式1$ rollup -w","tags":[{"name":"构建","slug":"构建","permalink":"https://derycktse.github.io/tags/构建/"}]},{"title":"使用Vue全家桶开发知乎日报","date":"2017-04-27T07:41:33.000Z","path":"2017/04/27/使用Vue全家桶开发知乎日报/","text":"使用Vue2 + vue-router + vuex 开发的知乎日报 github地址，如果觉得还可以，不妨给个star吧 起因因为经常看知乎日报，萌生了自己撸一个的想法，于是有了这个项目，不过github上面也有很多人做出来了 过程直接使用vue-cli脚手架开撸 问题分析图片防盗链使用代理网站 Images.weserv.nl代理知乎图片 接口跨域问题在本地启一个代理服务器(request )， 从而不会有跨域的问题 脚手架中已经集成了http-proxy-middleware作为代理，使用proxyTable即可代理接口，从而不会有跨域问题，用法见Proxy 代码结构(使用工具treer生成):12345678910111213141516171819202122src├─App.vue├─main.js├─store| └store.js├─router| └index.js├─components| ├─Carousel.vue| ├─List.vue| ├─NewsDetail.vue| └NewsList.vue├─common| └util.js├─assets| ├─logo.png| ├─top_logo.png| ├─css| | ├─reset.css| | └zhihu_base.css├─api| └index.js 参考知乎API分析","tags":[{"name":"Vue","slug":"Vue","permalink":"https://derycktse.github.io/tags/Vue/"}]},{"title":"实现拖拽","date":"2017-04-26T16:17:10.000Z","path":"2017/04/27/实现拖拽/","text":"今天在写一个拖拽效果，其实实现原理比较简单 通过mousedown, mousemove, mouseup加信号量，获取在移动中鼠标的位置clientX, clientY，从而修改元素的相对位置即可。 123456789101112131415161718192021222324252627function createDraggable(ele)&#123; /*mousedown mousemove mouseup*/ var moveFlag = false on(ele,'mousedown',function()&#123; moveFlag = true console.log('touch start') return true &#125;) on(ele,'mousemove',function(e)&#123; console.log('moving') if(!moveFlag) return var event = e || window.event var offsetX = e.clientX - 50 , offsetY = e.clientY - 50 ele.style.left = offsetX + 'px', ele.style.top = offsetY + 'px' &#125;) on(ele,'mouseup',function()&#123; moveFlag = false console.log('touch end') &#125;)&#125; 原本我的代码都是绑定在目标dom上，这个时候会发现当鼠标甩动过快的时候，焦点会在目标dom外，导致这个时候行为看起来很卡 接着修改1234567891011on(window,'mousemove',function(e)&#123; console.log('moving') if(!moveFlag) return var event = e || window.event var offsetX = e.clientX - 50 , offsetY = e.clientY - 50 ele.style.left = offsetX + 'px', ele.style.top = offsetY + 'px' &#125;) 主流浏览器看起来正常了，却发现IE8移动不了！！！ 最终发现应该是mousemove时间并没有冒泡到window对象上, 改为1234567891011on(document,'mousemove',function(e)&#123; console.log('moving') if(!moveFlag) return var event = e || window.event var offsetX = e.clientX - 50 , offsetY = e.clientY - 50 ele.style.left = offsetX + 'px', ele.style.top = offsetY + 'px' &#125;) 效果终于看起来OK啦见demo","tags":[]},{"title":"treer:命令行生成目录结构的实用小工具","date":"2017-04-23T03:12:58.000Z","path":"2017/04/23/treer-命令行生成目录结构的实用小工具/","text":"有时候在写说明文档的时，需要列出文件的一个目录结构,几次手动拼接之后，写了一个cli小工具来自动生成。 安装方法：1$ npm install treer -g 如此我们便可以快速的生成目录结构啦！ 生成结果1234567891011$ treerDesktop├─.DS_Store├─.localized├─dir2| ├─file3| └file4├─dir1| ├─dile2| └file1 指定目录默认的目录为当前的路径，可以通过-d 传入指定的路径 1$ treer -d &lt;指定路径&gt; 导出结果可将结果导出到文件中 1$ treer -e &lt;导出路径&gt; 忽略指定的目录有时候我们需要忽略一些文件名，比如我们的node_modules文件夹 1$ treer -i &lt;&quot;文件名，支持正则表达式/regex/哦&quot;&gt; 如果觉得实用，不妨Star一下吧，github地址","tags":[{"name":"node.js","slug":"node-js","permalink":"https://derycktse.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"https://derycktse.github.io/tags/npm/"}]},{"title":"javascript深浅拷贝","date":"2016-05-05T11:47:09.000Z","path":"2016/05/05/javascript深浅拷贝/","text":"javascript中分为基本类型跟引用类型两种，对于引用类型来说，变量实际上储存的是指针，对于变量的赋值，实际上也是复制指针地址，赋值后，我们对于变量的修改，也同样会影响到原来的变量 例如下面例子1234var object = &#123; a: 1, b: 2 &#125; ; var copy = object ; object.a = 3 ; console.log( copy.a ) ; 浅拷贝遍历对象的属性，将属性赋值给新创建的对象 123456789function shallowCopy(source)&#123; var cloneObj = &#123;&#125; for(var key in source)&#123; cloneObj[key] = source[key] &#125; return cloneObj&#125; 是不是很简单，不过，上面的代码有几个问题: 克隆出来的对象跟原本的对象原型链是不同的 原本原型链上的属性，被克隆到了新对象上作为自有属性了 只有可被枚举(emuerable)的属性被克隆了 属性的descriptor并没有被克隆，比如原本为只读的访问属性，被克隆成可读写的属性了 浅拷贝最重要的一个问题，如果属性本身是一个对象，那么克隆的对象以及原本的对象将共享这个属性 为了完善上面的问题，我们可以使用Object.getOwnPropertyNames()来配合完善, Object.keys只能返回可枚举的属性 我们来分析上面几个缺陷: 克隆出来的对象跟原本的对象原型链是不同的 我们可以通过获取原对象的原型对象(Object.getPrototypeOf)，再将克隆对象继承与该原型对象(Object.create) 原本原型链上的属性，被克隆到了新对象上作为自有属性了 只有可被枚举(emuerable)的属性被克隆了 在复制过程中，我们可以先判断属性是否为自由属性(Object.prototype.hasOwnProperty)，当然，我们可以更简单的使用Object.getOwnPropertyNames，它可返回所有的自有属性（包括不可枚举的） 属性的descriptor并没有被克隆，比如原本为只读的访问属性，被克隆成可读写的属性了\b通过Object.getOwnPropertyDescriptor获取属性的descriptor之后使用Object.defineProperty定义到克隆对象中 我们看下面的改良版12345678910function shallowCopy(source)&#123; var cloneObj = Object.create(Object.getPrototypeOf(source)) var keys = Object.getOwnPropertyNames(source) // `Object.keys`只能返回可枚举的属性 for(var i = 0; i &lt; keys.length ; i ++)&#123; Object.defineProperty(cloneObj, keys[i], Object.getOwnPropetyDescriptor(source, keys[i])) &#125; return cloneObj&#125; 深拷贝 参考understanding-object-cloning-in-javascript-part-i","tags":[{"name":"javascript","slug":"javascript","permalink":"https://derycktse.github.io/tags/javascript/"}]},{"title":"三个关于数组的小技巧","date":"2016-04-14T02:36:07.000Z","path":"2016/04/14/三个关于数组的小技巧/","text":"1.可迭代的空数组我们知道，Javacript的所创建的数组如果未被初始化值的话，它是一个稀疏数组(sparse array)，这是什么意思的？我们先看下面的代码1const arr = new Array(4); //[undefined, undefined, undefined, undefined] 假设我们要去迭代一个数组，我们会发现，未被初始化值的数组，index实际上访问不到的： 1arr.map((elem, index) =&gt; index); // 输出:[undefined, undefined, undefined, undefined] 我们分别来看Array.prototype.forEach和Array.prototype.map的描述，可以留意到：1map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. callback is invoked only for indexes of the array which have assigned values, including undefined. It is not called for missing elements of the array (that is, indexes that have never been set, which have been deleted or which have never been assigned a value). 1forEach() executes the provided callback once for each element present in the array in ascending order. It is not invoked for index properties that have been deleted or are uninitialized (i.e. on sparse arrays). 对于forEach与map这类方法，如果数组有未被初始化值的index, 默认是不回被遍历的。 那么， 如何创建一个所有值默认可被遍历的数组呢？很简单，我们只需要多加一步操作:12const arr = Array.apply(null, new Array(4)); //借助apply给每一个数组的每一个index都赋值arr.map((elem, index) =&gt; index); //这样的话改数组就可以遍历了, 输出 [0, 1, 2, 3] 2.利用数组给方法传递空参数我们调用方法的时候，有时想对一些参数进行忽略，比如下面的情况1method('parameter1', , 'parameter3'); //会报错， Uncaught SyntaxError: Unexpected token , 这个时候通常我们的做法是会传一个null 或者 undefined 作为占位123method('parameter1', null, 'parameter3')//或者method('paramter1', undefined, 'parameter3'); 我们可以借助ES6的展开语法(…)来辅助传参1method(...[&apos;parameter1&apos;, , &apos;paramter3&apos;]); // 大功告成! 3. 数组去重使用展开符号搭配set进行数组去重1const arr = [...new Set([1, 2, 3, 3])];//[1, 2, 3] 参考来源: 3 Array Hacks","tags":[{"name":"javascript","slug":"javascript","permalink":"https://derycktse.github.io/tags/javascript/"},{"name":"es2015","slug":"es2015","permalink":"https://derycktse.github.io/tags/es2015/"}]},{"title":"vue源码学习笔记","date":"2016-04-05T06:48:30.000Z","path":"2016/04/05/vue源码/","text":"[83fac017f96f34c92c3578796a7ddb443d4e1f17]使用grunt作为构建工具npm + component作为包的管理 [871ed9126639c9128c18bb2f19e6afd42c0c5ad9]新增加了一个数据绑定的实例大致思路： html结构中新增占位符号 将有占位符号的DOM保存起来，同时拥有一个对象将DOM关联起来 使用Object.defineProperty为这个对象的属性进行绑定访问器，如果修改了这个访问器的话，也将更改更新到DOM中 实例地址 [a5e27b1174e9196dcc9dbb0becc487275ea2e84c]作者同时使用了compoent的包管理工具看提交时间必须使用component@0.16.3这个版本 修改了main.js，主要思想即是通过解析拥有指定属性的DOM，然后将它们存入到对象之中，为这个对象绑定访问选择器（set,get）从而将更新修改到DOM中","tags":[]},{"title":"webpack使用require.ensure进行代码分割","date":"2016-03-15T20:52:13.000Z","path":"2016/03/16/webpack使用require-ensure进行代码分割/","text":"代码分割实例来自于webpack假定我们有下面的项目结构12345678.├── dist├── js│ ├── a.js│ ├── b.js│ ├── c.js│ └── entry.js└── webpack.config.js 文件内容entry.js12345require(&apos;./a&apos;);require.ensure([&apos;./b&apos;], function(require)&#123; require(&apos;./c&apos;); console.log(&apos;done!&apos;);&#125;); a.js1console.log(&apos;***** I AM a *****&apos;); b.js1console.log(&apos;***** I AM b *****&apos;); c.js1console.log(&apos;***** I AM c *****&apos;); 下面我们看一下webpack.config.js的配置12345678910111213const path = require('path')module.exports = &#123; entry : './js/entry.js' , output : &#123; filename : 'bundle.js' , path : path.resolve(__dirname, 'dist') , publicPath: './dist/' //当使用代码分割时，publicPath很重要，它将告诉webpack从哪儿去加载其他打包的文件 , pathinfo : true &#125; &#125; 执行webpack打包之后，我们可以看到结果 我们发现，webpack打包生成了bundle.js以及1.bundle.js两个文件查看文件的内容，我们可以发现 123456789101112131415161718192021222324252627282930313233343536//bundle.js/******/ (function(modules) &#123; // webpackBootstrap/******/ /* webpack 集成的代码，这里略 *//******/ __webpack_require__.p = \"./dist/\"; //按需加载的路径/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//*!*********************!*\\ !*** ./js/entry.js ***! \\*********************//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(/*! ./a */ 1) __webpack_require__.e/* nsure */(1, function (require) &#123; __webpack_require__(/*! ./c */ 3) console.log('done!') &#125;)/***/ &#125;,/* 1 *//*!*****************!*\\ !*** ./js/a.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am a')/***/ &#125;/******/ ]); 1234567891011121314151617181920//1.bundle.jswebpackJsonp([1],[/* 0 */,/* 1 */,/* 2 *//*!*****************!*\\ !*** ./js/b.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am b')/***/ &#125;,/* 3 *//*!*****************!*\\ !*** ./js/c.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am c')/***/ &#125;]); a.js的内容被打包到bundle.js之中,而b.js,c.js则位于1.bundle.js中,b.js,c.js从主入口文件中分离了出来，而且只有c.js的内容被执行了","tags":[{"name":"构建","slug":"构建","permalink":"https://derycktse.github.io/tags/构建/"}]},{"title":"为gulp任务传递参数","date":"2016-03-14T16:26:36.000Z","path":"2016/03/15/为gulp任务传递参数/","text":"现在web前端的脚手架中，有相当一部分数量的人选择用gulp做为首选的构建工具，但是，我们是没办法向gulp的任务直接传递命令行参数的。我们知道gulp实际上是运行在nodejs中的，那么，我们是可以访问process.argv比如命令gulp task1 --a 123 --b &quot;my string&quot; --c, 我们看看process.argv会输出什么12345678910['/usr/bin/nodejs','/home/user/.node_modules_global/bin/gulp','task1','--a','123','--b','my string','--c'] 既然可以拿到命令行输入的东西，那么我们就可以自己写一个参数解析的函数啦!123456789101112131415161718192021222324252627282930// fetch command line argumentsconst arg = (argList =&gt; &#123; let arg = &#123;&#125;, a, opt, thisOpt, curOpt; for (a = 0; a &lt; argList.length; a++) &#123; thisOpt = argList[a].trim(); opt = thisOpt.replace(/^\\-+/, ''); if (opt === thisOpt) &#123; // argument value if (curOpt) arg[curOpt] = opt; curOpt = null; &#125; else &#123; // argument name curOpt = opt; arg[curOpt] = true; &#125; &#125; return arg;&#125;)(process.argv);console.log(arg) //&#123; a: '123', b: 'my string', c: true &#125; 搞定！ 当然，这只是一个简单的实现。我们还可以使用功能更强大的库, 比如TJ大神的commander 参考How to Pass Command Line Parameters to Gulp Tasks","tags":[{"name":"构建","slug":"构建","permalink":"https://derycktse.github.io/tags/构建/"}]},{"title":"webpack入门","date":"2016-03-10T14:34:59.000Z","path":"2016/03/10/webpack入门/","text":"什么是webpackwebpack是一个module bundler，可以将把有依赖关系的各种文件打包成一系列的静态资源 安装首先我们安装最新版的webpack, 我安装的版本是2.2.11npm install -g webpack 下面我们将探讨webpack 2 的使用 我们可以直接在终端中使用webpack，命令如下123webpack &#123;源文件／入口文件&#125; &#123;目标文件&#125;webpack --watch //监听模式webpack -p //混淆脚本 考虑到随着我们项目复杂度的增高，有可能我们的配置选项也会很多，所以，我们完全可以将配置放到文件中, webpack在执行的时候默认会加载webpack.config.js文件作为配置, 如果我们需要指定配置文件的话，方法如下:1webpack --config &#123;配置文件&#125; 我们来看下webpack都有哪些配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189//webpack.config.jsconst path = require('path');module.exports = &#123; // click on the name of the option to get to the detailed documentation // click on the items with arrows to show more examples / advanced options entry: \"./app/entry\", // string | object | array // Here the application starts executing // and webpack starts bundling output: &#123; // options related to how webpack emits results path: path.resolve(__dirname, \"dist\"), // string // the target directory for all output files // must be an absolute path (use the Node.js path module) filename: \"bundle.js\", // string // the filename template for entry chunks publicPath: \"/assets/\", // string // the url to the output directory resolved relative to the HTML page library: \"MyLibrary\", // string, // the name of the exported library libraryTarget: \"umd\", // universal module definition // the type of the exported library /* Advanced output configuration (click to show) */ &#125;, module: &#123; // configuration regarding modules rules: [ // rules for modules (configure loaders, parser options, etc.) &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // these are matching conditions, each accepting a regular expression or string // test and include have the same behavior, both must be matched // exclude must not be matched (takes preferrence over test and include) // Best practices: // - Use RegExp only in test and for filename matching // - Use arrays of absolute paths in include and exclude // - Try to avoid exclude and prefer include issuer: &#123; test, include, exclude &#125;, // conditions for the issuer (the origin of the import) enforce: \"pre\", enforce: \"post\", // flags to apply these rules, even if they are overridden (advanced option) loader: \"babel-loader\", // the loader which should be applied, it'll be resolved relative to the context // -loader suffix is no longer optional in webpack2 for clarity reasons // see webpack 1 upgrade guide options: &#123; presets: [\"es2015\"] &#125;, // options for the loader &#125;, &#123; test: \"\\.html$\", use: [ // apply multiple loaders and options \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // only use one of these nested rules &#123; rules: [ /* rules */ ] &#125;, // use all of these nested rules (combine with conditions to be useful) &#123; resource: &#123; and: [ /* conditions */ ] &#125; &#125;, // matches only if all conditions are matched &#123; resource: &#123; or: [ /* conditions */ ] &#125; &#125;, &#123; resource: [ /* conditions */ ] &#125; // matches if any condition is matched (default for arrays) &#123; resource: &#123; not: /* condition */ &#125; &#125; // matches if the condition is not matched ], /* Advanced module configuration (click to show) */ &#125;, resolve: &#123; // options for resolving module requests // (does not apply to resolving to loaders) modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // directories where to look for modules extensions: [\".js\", \".json\", \".jsx\", \".css\"], // extensions that are used alias: &#123; // a list of module name aliases \"module\": \"new-module\", // alias \"module\" -&gt; \"new-module\" and \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // alias \"only-module\" -&gt; \"new-module\", but not \"module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // alias \"module\" -&gt; \"./app/third/module.js\" and \"module/file\" results in error // modules aliases are imported relative to the current context &#125;, /* alternative alias syntax (click to show) */ /* Advanced resolve configuration (click to show) */ &#125;, performance: &#123; hints: \"warning\", // enum maxAssetSize: 200000, // int (in bytes), maxEntrypointSize: 400000, // int (in bytes) assetFilter: function(assetFilename) &#123; // Function predicate that provides asset filenames return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum // enhance debugging by adding meta info for the browser devtools // source-map most detailed at the expense of build speed. context: __dirname, // string (absolute path!) // the home directory for webpack // the entry and module.rules.loader option // is resolved relative to this directory target: \"web\", // enum // the environment in which the bundle should run // changes chunk loading behavior and available modules externals: [\"react\", /^@angular\\//], // Don't follow/bundle these modules, but request them at runtime from the environment stats: \"errors-only\", // lets you precisely control what bundle information gets displayed devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // list of additional plugins /* Advanced configuration (click to show) */&#125; 下面我们来创建一个简单的项目我们的项目结构如下123456.├── dist├── src│ └── entry.js├── index.html└── webpack.config.js index.html123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src/entry.js1document.write(&apos;hello world&apos;) webpack.config.js123456789const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 在终端下运行命令:1webpack --watch 使用http-server起一个本地服务1http-server -p 8080 可以看到，entry.js的内容被打包到了bundle.js 中这是webpack最简单的应用，下面我们来看看如何使用loader loaderwebpack2中已经集成了json-loader, 所以我们无需安装其他的依赖在src中增加hello.json文件1&#123;\"greet\" : \"hello from json\"&#125; 修改entry.js12import json from './hello.json'document.write(json.greet) 刷新http://127.0.0.1:8080/可以看到hello.json的结果已经输出到浏览器中 使用其他loader如果其他格式的文件，比如css文件我们可以使用相应的loader来解析,安装依赖1npm install --save-dev style-loader css-loader 修改webpack.config.js123456789101112131415const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;] &#125;] &#125;&#125; entry.js123import &apos;./main.css&apos;import json from &apos;./hello.json&apos;document.write(json.greet) 可以看到，main.css也经过loader的解析而打包进bundle.js里面了","tags":[]},{"title":"浅谈javascript的原型及原型链","date":"2016-03-08T14:26:51.000Z","path":"2016/03/08/浅谈javascript的原型及原型链/","text":"原型与原型链是javascript里面最最核心的内容，如果不能理解它们之间的存在关系的话，那么我们是不能理解这门语言的。 在JS中，主要有两种创建对象的方法, 分别是对象字面量以及调用构造函数12345//对象字面量var obj1 = &#123;&#125;//调用构造函数var obj2 = new Object() 其实上述两种创建对象的方法，本质上是一样的，都是JS引擎调用对象的构造函数来新建出一个对象。构造函数本身也是一个普通的JS函数 下面我们来看一个例子12345678910111213141516171819202122//创建构造函数function Person(name)&#123; this.name = name&#125;//每个构造函数JS引擎都会自动添加一个prototype属性，我们称之为原型，这是一个对象//每个由构造函数创建的对象都会共享prototype上面的属性与方法console.log(typeof Person.prototype) // 'object'//我们为Person.prototype添加sayName方法Person.prototype.sayName = function()&#123; console.log(this.name)&#125;//创建实例var person1 = new Person('Messi')var person2 = new Person('Suarez')person1.sayName() // 'Messi'person2.sayName() // 'Suarez'person1.sayName === person2.sayName //true 我们借助上面的例子来理解构造函数-原型-实例，三者之间的关系，主要有几个基本概念 构造函数默认会有一个protoype属性指向它的原型 构造函数的原型会有一个consctructor的属性指向构造函数本身, 即 1Person.prototype.constructor === Person 每一个new出来的实例都有一个隐式的__proto__属性，指向它们的构造函数的原型，即 12person1.__proto__ === Person.prototypeperson1.__proto__.constructor === Person 了解了这些基本概念之后，我们再来看看javascript的一些原生构造函数的关系网，看下列的图 引自stackoverflow 按照我们上面的理解, Oject本身是一个构造函数，它也是一个对象，那么 1Object.__proto__ === Function.prototype 为了方便我们记住上图，还有几个需要我们知道的特殊概念： Function的原型属性与Function的原型指向同一个对象. 即是 1Function.__proto__ == Function.prototype Object.prototype.__proto__ === null typeof Function.prototype === &#39;function&#39; 参考[在JavaScript中，Function构造函数本身也算是Function类型的实例吗？][https://www.zhihu.com/question/31333084/answer/152086175]","tags":[{"name":"javascript","slug":"javascript","permalink":"https://derycktse.github.io/tags/javascript/"},{"name":"prototype","slug":"prototype","permalink":"https://derycktse.github.io/tags/prototype/"}]},{"title":"ES2015读书笔记","date":"2016-02-22T17:12:12.000Z","path":"2016/02/23/ES2015读书笔记/","text":"变量的解构赋值 “模式匹配”： 只要等号两边的模式相同，左边的变量久会被赋予相应的值；如果解构不成功，变量的值就等于undefined。 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; //因为x能取到值，所以函数f根本不会执行 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 对象的解构赋值 数组的元素是按次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值 对象的解构赋值的内部机制，是：先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者(注:对象解构赋值只看分号后面的，如果有的话) 1234let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined//上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 参考ECMAScript 6 入门","tags":[]},{"title":"构建工具的对比","date":"2015-12-24T06:36:18.000Z","path":"2015/12/24/构建工具的对比/","text":"grunt与gulp同为构建工具，而webpack本身则为打包工具，定位不同，所以，下面比价的是grunt跟gulp Gulp和Grunt的比较 Gulp相比Grunt更简洁，而且遵循代码优于配置策略，维护Gulp更像是写代码。 Gulp相比Grunt更有设计感，核心设计基于Unix流的概念，通过管道连接，不需要写中间文件。 Gulp的核心API只有5个，掌握了5个API就学会了Gulp，之后便可以通过管道流组合自己想要的任务。 所以相对grunt来说， gulp的性能更加高效，所以grunt我们直接无视 gulpGulp 的定位是 Task Runner, 就是用来跑一个一个任务的。gulp是通过一系列插件将原本复杂繁琐的任务自动化，是一个纯粹的工具，并不能将你的css等非js资源模块化，但是webpack可以做到这些。总的来说，gulp是一个自动化任务的工具，所以你可以通过gulp来配置webpack的文件。 Gulp侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给gulp配置不通的task（通过Gulp中的gulp.task()方法配置，比如启动server、sass/less预编译、文件的合并压缩等等）来让gulp实现不同的功能，从而构建整个前端开发流程。特点： 配置较为简单，学习成本相对低点 不能将css等非js资源模块化 压缩，sourcemap等需要借助插件 定位为task runner webpackwebpack只是具有前端构建的功能而已，其实本质来说webpack是一种模块化的解决方案类似require.js一样，只不过通过插件实现了构建工具的一些功能，例如通过less－loader可以编译less为css并作为模块可以被调用。 Webpack更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js文件、css文件等）都可以看成模块，最初Webpack本身就是为前端JS代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack是通过loader（加载器）和plugins（插件）对资源进行处理的 特点： webpack 遵循commonJS 的形式，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS ，所有的静态资源，例如css，图片等都能模块化，即以require的方式引入。 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等 主要定位还是module bundler，在实际开发过程中比如上传ftp等，则无法做到","tags":[{"name":"构建","slug":"构建","permalink":"https://derycktse.github.io/tags/构建/"}]}]