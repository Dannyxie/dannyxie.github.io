[{"title":"三个关于数组的小技巧","date":"2016-04-14T02:36:07.000Z","path":"2016/04/14/三个关于数组的小技巧/","text":"1.可迭代的空数组我们知道，Javacript的所创建的数组如果未被初始化值的话，它是一个稀疏数组(sparse array)，这是什么意思的？我们先看下面的代码1const arr = new Array(4); //[undefined, undefined, undefined, undefined] 假设我们要去迭代一个数组，我们会发现，未被初始化值的数组，index实际上访问不到的： 1arr.map((elem, index) =&gt; index); // 输出:[undefined, undefined, undefined, undefined] 我们分别来看Array.prototype.forEach和Array.prototype.map的描述，可以留意到：1map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. callback is invoked only for indexes of the array which have assigned values, including undefined. It is not called for missing elements of the array (that is, indexes that have never been set, which have been deleted or which have never been assigned a value). 1forEach() executes the provided callback once for each element present in the array in ascending order. It is not invoked for index properties that have been deleted or are uninitialized (i.e. on sparse arrays). 对于forEach与map这类方法，如果数组有未被初始化值的index, 默认是不回被遍历的。 那么， 如何创建一个所有值默认可被遍历的数组呢？很简单，我们只需要多加一步操作:12const arr = Array.apply(null, new Array(4)); //借助apply给每一个数组的每一个index都赋值arr.map((elem, index) =&gt; index); //这样的话改数组就可以遍历了, 输出 [0, 1, 2, 3] 2.利用数组给方法传递空参数我们调用方法的时候，有时想对一些参数进行忽略，比如下面的情况1method('parameter1', , 'parameter3'); //会报错， Uncaught SyntaxError: Unexpected token , 这个时候通常我们的做法是会传一个null 或者 undefined 作为占位123method('parameter1', null, 'parameter3')//或者method('paramter1', undefined, 'parameter3'); 我们可以借助ES6的展开语法(…)来辅助传参1method(...[&apos;parameter1&apos;, , &apos;paramter3&apos;]); // 大功告成! ###3. 数组去重###使用展开符号搭配set进行数组去重1const arr = [...new Set([1, 2, 3, 3])];//[1, 2, 3] 参考来源: 3 Array Hacks","tags":[]},{"title":"webpack使用require.ensure进行代码分割","date":"2016-03-15T20:52:13.000Z","path":"2016/03/16/webpack使用require-ensure进行代码分割/","text":"代码分割实例来自于webpack假定我们有下面的项目结构12345678.├── dist├── js│ ├── a.js│ ├── b.js│ ├── c.js│ └── entry.js└── webpack.config.js 文件内容entry.js12345require(&apos;./a&apos;);require.ensure([&apos;./b&apos;], function(require)&#123; require(&apos;./c&apos;); console.log(&apos;done!&apos;);&#125;); a.js1console.log(&apos;***** I AM a *****&apos;); b.js1console.log(&apos;***** I AM b *****&apos;); c.js1console.log(&apos;***** I AM c *****&apos;); 下面我们看一下webpack.config.js的配置12345678910111213const path = require('path')module.exports = &#123; entry : './js/entry.js' , output : &#123; filename : 'bundle.js' , path : path.resolve(__dirname, 'dist') , publicPath: './dist/' //当使用代码分割时，publicPath很重要，它将告诉webpack从哪儿去加载其他打包的文件 , pathinfo : true &#125; &#125; 执行webpack打包之后，我们可以看到结果 我们发现，webpack打包生成了bundle.js以及1.bundle.js两个文件查看文件的内容，我们可以发现 123456789101112131415161718192021222324252627282930313233343536//bundle.js/******/ (function(modules) &#123; // webpackBootstrap/******/ /* webpack 集成的代码，这里略 *//******/ __webpack_require__.p = \"./dist/\"; //按需加载的路径/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//*!*********************!*\\ !*** ./js/entry.js ***! \\*********************//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(/*! ./a */ 1) __webpack_require__.e/* nsure */(1, function (require) &#123; __webpack_require__(/*! ./c */ 3) console.log('done!') &#125;)/***/ &#125;,/* 1 *//*!*****************!*\\ !*** ./js/a.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am a')/***/ &#125;/******/ ]); 1234567891011121314151617181920//1.bundle.jswebpackJsonp([1],[/* 0 */,/* 1 */,/* 2 *//*!*****************!*\\ !*** ./js/b.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am b')/***/ &#125;,/* 3 *//*!*****************!*\\ !*** ./js/c.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am c')/***/ &#125;]); a.js的内容被打包到bundle.js之中,而b.js,c.js则位于1.bundle.js中,b.js,c.js从主入口文件中分离了出来，而且只有c.js的内容被执行了","tags":[{"name":"构建","slug":"构建","permalink":"https://dannyxie.github.io/tags/构建/"}]},{"title":"webpack入门","date":"2016-03-10T14:34:59.000Z","path":"2016/03/10/webpack入门/","text":"什么是webpackwebpack是一个module bundler，可以将把有依赖关系的各种文件打包成一系列的静态资源 安装首先我们安装最新版的webpack, 我安装的版本是2.2.11npm install -g webpack 下面我们将探讨webpack 2 的使用 我们可以直接在终端中使用webpack，命令如下123webpack &#123;源文件／入口文件&#125; &#123;目标文件&#125;webpack --watch //监听模式webpack -p //混淆脚本 考虑到随着我们项目复杂度的增高，有可能我们的配置选项也会很多，所以，我们完全可以将配置放到文件中, webpack在执行的时候默认会加载webpack.config.js文件作为配置, 如果我们需要指定配置文件的话，方法如下:1webpack --config &#123;配置文件&#125; 下面我们来创建一个简单的项目我们的项目结构如下123456.├── dist├── src│ └── entry.js├── index.html└── webpack.config.js index.html123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src/entry.js1document.write(&apos;hello world&apos;) webpack.config.js123456789const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 在终端下运行命令:1webpack --watch 使用http-server起一个本地服务1http-server -p 8080 可以看到，entry.js的内容被打包到了bundle.js 中这是webpack最简单的应用，下面我们来看看如何使用loader loaderwebpack2中已经集成了json-loader, 所以我们无需安装其他的依赖在src中增加hello.json文件1&#123;\"greet\" : \"hello from json\"&#125; 修改entry.js12import json from './hello.json'document.write(json.greet) 刷新http://127.0.0.1:8080/可以看到hello.json的结果已经输出到浏览器中 使用其他loader如果其他格式的文件，比如css文件我们可以使用相应的loader来解析,安装依赖1npm install --save-dev style-loader css-loader 修改webpack.config.js123456789101112131415const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;] &#125;] &#125;&#125; entry.js123import &apos;./main.css&apos;import json from &apos;./hello.json&apos;document.write(json.greet) 可以看到，main.css也经过loader的解析而打包进bundle.js里面了","tags":[]},{"title":"浅谈javascript的原型及原型链","date":"2016-03-08T14:26:51.000Z","path":"2016/03/08/浅谈javascript的原型及原型链/","text":"原型与原型链是javascript里面最最核心的内容，如果不能理解它们之间的存在关系的话，那么我们是不能理解这门语言的。 在JS中，主要有两种创建对象的方法, 分别是对象字面量以及调用构造函数12345//对象字面量var obj1 = &#123;&#125;//调用构造函数var obj2 = new Object() 其实上述两种创建对象的方法，本质上是一样的，都是JS引擎调用对象的构造函数来新建出一个对象。构造函数本身也是一个普通的JS函数 下面我们来看一个例子1234567891011121314151617181920212223//创建构造函数function Person(name)&#123; this.name = name&#125;//每个构造函数JS引擎都会自动添加一个prototype属性，我们称之为原型，这是一个对象//每个由构造函数创建的对象都会共享prototype上面的属性与方法console.log(typeof Person.prototype) // 'object'//我们为Person.prototype添加sayName方法Person.prototype.sayName = function()&#123; console.log(this.name)&#125;//创建实例var person1 = new Person('Messi')var person2 = new Person('Suarez')person1.sayName() // 'Messi'person2.sayName() // 'Suarez'person1.sayName === person2.sayName //true 我们借助上面的例子来理解构造函数-原型-实例，三者之间的关系，主要有几个基本概念 构造函数默认会有一个protoype属性指向它的原型 构造函数的原型会有一个consctructor的属性指向构造函数本身, 即 1Person.prototype.constructor === Person 每一个new出来的实例都有一个隐式的__proto__属性，指向它们的构造函数的原型，即 12person1.__proto__ === Person.prototypeperson1.__proto__.constructor === Person 了解了这些基本概念之后，我们再来看看javascript的一些原生构造函数的关系网，看下列的图 引自stackoverflow 按照我们上面的理解, Oject本身是一个构造函数，它也是一个对象，那么 1Object.__proto__ === Function.prototype 为了方便我们记住上图，还有几个需要我们知道的特殊概念： Function的原型属性与Function的原型指向同一个对象. 即 1Function.__proto__ == Function.prototype Object.prototype.__proto__ === null typeof Function.prototype === &#39;function&#39;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://dannyxie.github.io/tags/javascript/"},{"name":"prototype","slug":"prototype","permalink":"https://dannyxie.github.io/tags/prototype/"}]}]