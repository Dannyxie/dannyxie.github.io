[{"title":"三个关于数组的小技巧","date":"2016-04-14T02:36:07.000Z","path":"2016/04/14/三个关于数组的小技巧/","text":"1.可迭代的空数组我们知道，Javacript的所创建的数组如果未被初始化值的话，它是一个稀疏数组(sparse array)，这是什么意思的？我们先看下面的代码1const arr = new Array(4); //[undefined, undefined, undefined, undefined] 假设我们要去迭代一个数组，我们会发现，未被初始化值的数组，index实际上访问不到的： 1arr.map((elem, index) =&gt; index); // 输出:[undefined, undefined, undefined, undefined] 我们分别来看Array.prototype.forEach和Array.prototype.map的描述，可以留意到：1map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. callback is invoked only for indexes of the array which have assigned values, including undefined. It is not called for missing elements of the array (that is, indexes that have never been set, which have been deleted or which have never been assigned a value). 1forEach() executes the provided callback once for each element present in the array in ascending order. It is not invoked for index properties that have been deleted or are uninitialized (i.e. on sparse arrays). 对于forEach与map这类方法，如果数组有未被初始化值的index, 默认是不回被遍历的。 那么， 如何创建一个所有值默认可被遍历的数组呢？很简单，我们只需要多加一步操作:12const arr = Array.apply(null, new Array(4)); //借助apply给每一个数组的每一个index都赋值arr.map((elem, index) =&gt; index); //这样的话改数组就可以遍历了, 输出 [0, 1, 2, 3] 2.利用数组给方法传递空参数我们调用方法的时候，有时想对一些参数进行忽略，比如下面的情况1method('parameter1', , 'parameter3'); //会报错， Uncaught SyntaxError: Unexpected token , 这个时候通常我们的做法是会传一个null 或者 undefined 作为占位123method('parameter1', null, 'parameter3')//或者method('paramter1', undefined, 'parameter3'); 我们可以借助ES6的展开语法(…)来辅助传参1method(...[&apos;parameter1&apos;, , &apos;paramter3&apos;]); // 大功告成! 3. 数组去重使用展开符号搭配set进行数组去重1const arr = [...new Set([1, 2, 3, 3])];//[1, 2, 3] 参考来源: 3 Array Hacks","tags":[{"name":"es2015","slug":"es2015","permalink":"https://derycktse.github.io/tags/es2015/"},{"name":"javascript","slug":"javascript","permalink":"https://derycktse.github.io/tags/javascript/"}]},{"title":"webpack使用require.ensure进行代码分割","date":"2016-03-15T20:52:13.000Z","path":"2016/03/16/webpack使用require-ensure进行代码分割/","text":"代码分割实例来自于webpack假定我们有下面的项目结构12345678.├── dist├── js│ ├── a.js│ ├── b.js│ ├── c.js│ └── entry.js└── webpack.config.js 文件内容entry.js12345require(&apos;./a&apos;);require.ensure([&apos;./b&apos;], function(require)&#123; require(&apos;./c&apos;); console.log(&apos;done!&apos;);&#125;); a.js1console.log(&apos;***** I AM a *****&apos;); b.js1console.log(&apos;***** I AM b *****&apos;); c.js1console.log(&apos;***** I AM c *****&apos;); 下面我们看一下webpack.config.js的配置12345678910111213const path = require('path')module.exports = &#123; entry : './js/entry.js' , output : &#123; filename : 'bundle.js' , path : path.resolve(__dirname, 'dist') , publicPath: './dist/' //当使用代码分割时，publicPath很重要，它将告诉webpack从哪儿去加载其他打包的文件 , pathinfo : true &#125; &#125; 执行webpack打包之后，我们可以看到结果 我们发现，webpack打包生成了bundle.js以及1.bundle.js两个文件查看文件的内容，我们可以发现 123456789101112131415161718192021222324252627282930313233343536//bundle.js/******/ (function(modules) &#123; // webpackBootstrap/******/ /* webpack 集成的代码，这里略 *//******/ __webpack_require__.p = \"./dist/\"; //按需加载的路径/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//*!*********************!*\\ !*** ./js/entry.js ***! \\*********************//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(/*! ./a */ 1) __webpack_require__.e/* nsure */(1, function (require) &#123; __webpack_require__(/*! ./c */ 3) console.log('done!') &#125;)/***/ &#125;,/* 1 *//*!*****************!*\\ !*** ./js/a.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am a')/***/ &#125;/******/ ]); 1234567891011121314151617181920//1.bundle.jswebpackJsonp([1],[/* 0 */,/* 1 */,/* 2 *//*!*****************!*\\ !*** ./js/b.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am b')/***/ &#125;,/* 3 *//*!*****************!*\\ !*** ./js/c.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am c')/***/ &#125;]); a.js的内容被打包到bundle.js之中,而b.js,c.js则位于1.bundle.js中,b.js,c.js从主入口文件中分离了出来，而且只有c.js的内容被执行了","tags":[{"name":"构建","slug":"构建","permalink":"https://derycktse.github.io/tags/构建/"}]},{"title":"为gulp任务传递参数","date":"2016-03-14T16:26:36.000Z","path":"2016/03/15/为gulp任务传递参数/","text":"现在web前端的脚手架中，有相当一部分数量的人选择用gulp做为首选的构建工具，但是，我们是没办法向gulp的任务直接传递命令行参数的。我们知道gulp实际上是运行在nodejs中的，那么，我们是可以访问process.argv比如命令gulp task1 --a 123 --b &quot;my string&quot; --c, 我们看看process.argv会输出什么12345678910['/usr/bin/nodejs','/home/user/.node_modules_global/bin/gulp','task1','--a','123','--b','my string','--c'] 既然可以拿到命令行输入的东西，那么我们就可以自己写一个参数解析的函数啦!123456789101112131415161718192021222324252627282930// fetch command line argumentsconst arg = (argList =&gt; &#123; let arg = &#123;&#125;, a, opt, thisOpt, curOpt; for (a = 0; a &lt; argList.length; a++) &#123; thisOpt = argList[a].trim(); opt = thisOpt.replace(/^\\-+/, ''); if (opt === thisOpt) &#123; // argument value if (curOpt) arg[curOpt] = opt; curOpt = null; &#125; else &#123; // argument name curOpt = opt; arg[curOpt] = true; &#125; &#125; return arg;&#125;)(process.argv);console.log(arg) //&#123; a: '123', b: 'my string', c: true &#125; 搞定！ 当然，这只是一个简单的实现。我们还可以使用功能更强大的库, 比如TJ大神的commander 参考How to Pass Command Line Parameters to Gulp Tasks","tags":[{"name":"构建","slug":"构建","permalink":"https://derycktse.github.io/tags/构建/"}]},{"title":"webpack入门","date":"2016-03-10T14:34:59.000Z","path":"2016/03/10/webpack入门/","text":"什么是webpackwebpack是一个module bundler，可以将把有依赖关系的各种文件打包成一系列的静态资源 安装首先我们安装最新版的webpack, 我安装的版本是2.2.11npm install -g webpack 下面我们将探讨webpack 2 的使用 我们可以直接在终端中使用webpack，命令如下123webpack &#123;源文件／入口文件&#125; &#123;目标文件&#125;webpack --watch //监听模式webpack -p //混淆脚本 考虑到随着我们项目复杂度的增高，有可能我们的配置选项也会很多，所以，我们完全可以将配置放到文件中, webpack在执行的时候默认会加载webpack.config.js文件作为配置, 如果我们需要指定配置文件的话，方法如下:1webpack --config &#123;配置文件&#125; 我们来看下webpack都有哪些配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189//webpack.config.jsconst path = require('path');module.exports = &#123; // click on the name of the option to get to the detailed documentation // click on the items with arrows to show more examples / advanced options entry: \"./app/entry\", // string | object | array // Here the application starts executing // and webpack starts bundling output: &#123; // options related to how webpack emits results path: path.resolve(__dirname, \"dist\"), // string // the target directory for all output files // must be an absolute path (use the Node.js path module) filename: \"bundle.js\", // string // the filename template for entry chunks publicPath: \"/assets/\", // string // the url to the output directory resolved relative to the HTML page library: \"MyLibrary\", // string, // the name of the exported library libraryTarget: \"umd\", // universal module definition // the type of the exported library /* Advanced output configuration (click to show) */ &#125;, module: &#123; // configuration regarding modules rules: [ // rules for modules (configure loaders, parser options, etc.) &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // these are matching conditions, each accepting a regular expression or string // test and include have the same behavior, both must be matched // exclude must not be matched (takes preferrence over test and include) // Best practices: // - Use RegExp only in test and for filename matching // - Use arrays of absolute paths in include and exclude // - Try to avoid exclude and prefer include issuer: &#123; test, include, exclude &#125;, // conditions for the issuer (the origin of the import) enforce: \"pre\", enforce: \"post\", // flags to apply these rules, even if they are overridden (advanced option) loader: \"babel-loader\", // the loader which should be applied, it'll be resolved relative to the context // -loader suffix is no longer optional in webpack2 for clarity reasons // see webpack 1 upgrade guide options: &#123; presets: [\"es2015\"] &#125;, // options for the loader &#125;, &#123; test: \"\\.html$\", use: [ // apply multiple loaders and options \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // only use one of these nested rules &#123; rules: [ /* rules */ ] &#125;, // use all of these nested rules (combine with conditions to be useful) &#123; resource: &#123; and: [ /* conditions */ ] &#125; &#125;, // matches only if all conditions are matched &#123; resource: &#123; or: [ /* conditions */ ] &#125; &#125;, &#123; resource: [ /* conditions */ ] &#125; // matches if any condition is matched (default for arrays) &#123; resource: &#123; not: /* condition */ &#125; &#125; // matches if the condition is not matched ], /* Advanced module configuration (click to show) */ &#125;, resolve: &#123; // options for resolving module requests // (does not apply to resolving to loaders) modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // directories where to look for modules extensions: [\".js\", \".json\", \".jsx\", \".css\"], // extensions that are used alias: &#123; // a list of module name aliases \"module\": \"new-module\", // alias \"module\" -&gt; \"new-module\" and \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // alias \"only-module\" -&gt; \"new-module\", but not \"module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // alias \"module\" -&gt; \"./app/third/module.js\" and \"module/file\" results in error // modules aliases are imported relative to the current context &#125;, /* alternative alias syntax (click to show) */ /* Advanced resolve configuration (click to show) */ &#125;, performance: &#123; hints: \"warning\", // enum maxAssetSize: 200000, // int (in bytes), maxEntrypointSize: 400000, // int (in bytes) assetFilter: function(assetFilename) &#123; // Function predicate that provides asset filenames return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum // enhance debugging by adding meta info for the browser devtools // source-map most detailed at the expense of build speed. context: __dirname, // string (absolute path!) // the home directory for webpack // the entry and module.rules.loader option // is resolved relative to this directory target: \"web\", // enum // the environment in which the bundle should run // changes chunk loading behavior and available modules externals: [\"react\", /^@angular\\//], // Don't follow/bundle these modules, but request them at runtime from the environment stats: \"errors-only\", // lets you precisely control what bundle information gets displayed devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // list of additional plugins /* Advanced configuration (click to show) */&#125; 下面我们来创建一个简单的项目我们的项目结构如下123456.├── dist├── src│ └── entry.js├── index.html└── webpack.config.js index.html123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src/entry.js1document.write(&apos;hello world&apos;) webpack.config.js123456789const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 在终端下运行命令:1webpack --watch 使用http-server起一个本地服务1http-server -p 8080 可以看到，entry.js的内容被打包到了bundle.js 中这是webpack最简单的应用，下面我们来看看如何使用loader loaderwebpack2中已经集成了json-loader, 所以我们无需安装其他的依赖在src中增加hello.json文件1&#123;\"greet\" : \"hello from json\"&#125; 修改entry.js12import json from './hello.json'document.write(json.greet) 刷新http://127.0.0.1:8080/可以看到hello.json的结果已经输出到浏览器中 使用其他loader如果其他格式的文件，比如css文件我们可以使用相应的loader来解析,安装依赖1npm install --save-dev style-loader css-loader 修改webpack.config.js123456789101112131415const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;] &#125;] &#125;&#125; entry.js123import &apos;./main.css&apos;import json from &apos;./hello.json&apos;document.write(json.greet) 可以看到，main.css也经过loader的解析而打包进bundle.js里面了","tags":[]},{"title":"浅谈javascript的原型及原型链","date":"2016-03-08T14:26:51.000Z","path":"2016/03/08/浅谈javascript的原型及原型链/","text":"原型与原型链是javascript里面最最核心的内容，如果不能理解它们之间的存在关系的话，那么我们是不能理解这门语言的。 在JS中，主要有两种创建对象的方法, 分别是对象字面量以及调用构造函数12345//对象字面量var obj1 = &#123;&#125;//调用构造函数var obj2 = new Object() 其实上述两种创建对象的方法，本质上是一样的，都是JS引擎调用对象的构造函数来新建出一个对象。构造函数本身也是一个普通的JS函数 下面我们来看一个例子12345678910111213141516171819202122//创建构造函数function Person(name)&#123; this.name = name&#125;//每个构造函数JS引擎都会自动添加一个prototype属性，我们称之为原型，这是一个对象//每个由构造函数创建的对象都会共享prototype上面的属性与方法console.log(typeof Person.prototype) // 'object'//我们为Person.prototype添加sayName方法Person.prototype.sayName = function()&#123; console.log(this.name)&#125;//创建实例var person1 = new Person('Messi')var person2 = new Person('Suarez')person1.sayName() // 'Messi'person2.sayName() // 'Suarez'person1.sayName === person2.sayName //true 我们借助上面的例子来理解构造函数-原型-实例，三者之间的关系，主要有几个基本概念 构造函数默认会有一个protoype属性指向它的原型 构造函数的原型会有一个consctructor的属性指向构造函数本身, 即 1Person.prototype.constructor === Person 每一个new出来的实例都有一个隐式的__proto__属性，指向它们的构造函数的原型，即 12person1.__proto__ === Person.prototypeperson1.__proto__.constructor === Person 了解了这些基本概念之后，我们再来看看javascript的一些原生构造函数的关系网，看下列的图 引自stackoverflow 按照我们上面的理解, Oject本身是一个构造函数，它也是一个对象，那么 1Object.__proto__ === Function.prototype 为了方便我们记住上图，还有几个需要我们知道的特殊概念： Function的原型属性与Function的原型指向同一个对象. 即是 1Function.__proto__ == Function.prototype Object.prototype.__proto__ === null typeof Function.prototype === &#39;function&#39;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://derycktse.github.io/tags/javascript/"},{"name":"prototype","slug":"prototype","permalink":"https://derycktse.github.io/tags/prototype/"}]}]