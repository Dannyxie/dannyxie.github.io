[{"title":"webpack使用require.ensure进行代码分割","date":"2016-03-15T20:52:13.000Z","path":"2016/03/16/webpack使用require-ensure进行代码分割/","text":"代码分割实例来自于webpack假定我们有下面的项目结构12345678.├── dist├── js│ ├── a.js│ ├── b.js│ ├── c.js│ └── entry.js└── webpack.config.js 文件内容entry.js12345require(&apos;./a&apos;);require.ensure([&apos;./b&apos;], function(require)&#123; require(&apos;./c&apos;); console.log(&apos;done!&apos;);&#125;); a.js1console.log(&apos;***** I AM a *****&apos;); b.js1console.log(&apos;***** I AM b *****&apos;); c.js1console.log(&apos;***** I AM c *****&apos;); 下面我们看一下webpack.config.js的配置12345678910111213const path = require('path')module.exports = &#123; entry : './js/entry.js' , output : &#123; filename : 'bundle.js' , path : path.resolve(__dirname, 'dist') , publicPath: './dist/' //当使用代码分割时，publicPath很重要，它将告诉webpack从哪儿去加载其他打包的文件 , pathinfo : true &#125; &#125; 执行webpack打包之后，我们可以看到结果 我们发现，webpack打包生成了bundle.js以及1.bundle.js两个文件查看文件的内容，我们可以发现 123456789101112131415161718192021222324252627282930313233343536//bundle.js/******/ (function(modules) &#123; // webpackBootstrap/******/ /* webpack 集成的代码，这里略 *//******/ __webpack_require__.p = \"./dist/\"; //按需加载的路径/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//*!*********************!*\\ !*** ./js/entry.js ***! \\*********************//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(/*! ./a */ 1) __webpack_require__.e/* nsure */(1, function (require) &#123; __webpack_require__(/*! ./c */ 3) console.log('done!') &#125;)/***/ &#125;,/* 1 *//*!*****************!*\\ !*** ./js/a.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am a')/***/ &#125;/******/ ]); 1234567891011121314151617181920//1.bundle.jswebpackJsonp([1],[/* 0 */,/* 1 */,/* 2 *//*!*****************!*\\ !*** ./js/b.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am b')/***/ &#125;,/* 3 *//*!*****************!*\\ !*** ./js/c.js ***! \\*****************//***/ function(module, exports) &#123; console.log('I am c')/***/ &#125;]); a.js的内容被打包到bundle.js之中,而b.js,c.js则位于1.bundle.js中,b.js,c.js从主入口文件中分离了出来，而且只有c.js的内容被执行了","tags":[]},{"title":"webpack入门","date":"2016-03-10T14:34:59.000Z","path":"2016/03/10/webpack入门/","text":"什么是webpackwebpack是一个module bundler，可以将把有依赖关系的各种文件打包成一系列的静态资源 安装首先我们安装最新版的webpack, 我安装的版本是2.2.11npm install -g webpack 下面我们将探讨webpack 2 的使用 我们可以直接在终端中使用webpack，命令如下123webpack &#123;源文件／入口文件&#125; &#123;目标文件&#125;webpack --watch //监听模式webpack -p //混淆脚本 考虑到随着我们项目复杂度的增高，有可能我们的配置选项也会很多，所以，我们完全可以将配置放到文件中, webpack在执行的时候默认会加载webpack.config.js文件作为配置, 如果我们需要指定配置文件的话，方法如下:1webpack --config &#123;配置文件&#125; 下面我们来创建一个简单的项目我们的项目结构如下123456.├── dist├── src│ └── entry.js├── index.html└── webpack.config.js index.html123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src/entry.js1document.write(&apos;hello world&apos;) webpack.config.js123456789const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 在终端下运行命令:1webpack --watch 使用http-server起一个本地服务1http-server -p 8080 可以看到，entry.js的内容被打包到了bundle.js 中这是webpack最简单的应用，下面我们来看看如何使用loader loaderwebpack2中已经集成了json-loader, 所以我们无需安装其他的依赖在src中增加hello.json文件1&#123;\"greet\" : \"hello from json\"&#125; 修改entry.js12import json from './hello.json'document.write(json.greet) 刷新http://127.0.0.1:8080/可以看到hello.json的结果已经输出到浏览器中 使用其他loader如果其他格式的文件，比如css文件我们可以使用相应的loader来解析,安装依赖1npm install --save-dev style-loader css-loader 修改webpack.config.js123456789101112131415const path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/entry.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;] &#125;] &#125;&#125; entry.js123import &apos;./main.css&apos;import json from &apos;./hello.json&apos;document.write(json.greet) 可以看到，main.css也经过loader的解析而打包进bundle.js里面了","tags":[]},{"title":"浅谈javascript的原型及原型链","date":"2016-03-08T14:26:51.000Z","path":"2016/03/08/浅谈javascript的原型及原型链/","text":"原型与原型链是javascript里面最最核心的内容，如果不能理解它们之间的存在关系的话，那么我们是不能理解这门语言的。 在JS中，主要有两种创建对象的方法, 分别是对象字面量以及调用构造函数12345//对象字面量var obj1 = &#123;&#125;//调用构造函数var obj2 = new Object() 其实上述两种创建对象的方法，本质上是一样的，都是JS引擎调用对象的构造函数来新建出一个对象。构造函数本身也是一个普通的JS函数 下面我们来看一个例子1234567891011121314151617181920212223//创建构造函数function Person(name)&#123; this.name = name&#125;//每个构造函数JS引擎都会自动添加一个prototype属性，我们称之为原型，这是一个对象//每个由构造函数创建的对象都会共享prototype上面的属性与方法console.log(typeof Person.prototype) // 'object'//我们为Person.prototype添加sayName方法Person.prototype.sayName = function()&#123; console.log(this.name)&#125;//创建实例var person1 = new Person('Messi')var person2 = new Person('Suarez')person1.sayName() // 'Messi'person2.sayName() // 'Suarez'person1.sayName === person2.sayName //true 我们借助上面的例子来理解构造函数-原型-实例，三者之间的关系，主要有几个基本概念 构造函数默认会有一个protoype属性指向它的原型 构造函数的原型会有一个consctructor的属性指向构造函数本身, 即 1Person.prototype.constructor === Person 每一个new出来的实例都有一个隐式的__proto__属性，指向它们的构造函数的原型，即 12person1.__proto__ === Person.prototypeperson1.__proto__.constructor === Person 了解了这些基本概念之后，我们再来看看javascript的一些原生构造函数的关系网，看下列的图 引自stackoverflow 按照我们上面的理解, Oject本身是一个构造函数，它也是一个对象，那么 1Object.__proto__ === Function.prototype 为了方便我们记住上图，还有几个需要我们知道的特殊概念： Function的原型属性与Function的原型指向同一个对象. 即 1Function.__proto__ == Function.prototype Object.prototype.__proto__ === null typeof Function.prototype === &#39;function&#39;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"prototype","slug":"prototype","permalink":"http://yoursite.com/tags/prototype/"}]}]