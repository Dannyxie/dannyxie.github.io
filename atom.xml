<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deryck</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dannyxie.github.io/"/>
  <updated>2017-03-14T02:45:08.000Z</updated>
  <id>https://dannyxie.github.io/</id>
  
  <author>
    <name>Deryck</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三个关于数组的小技巧</title>
    <link href="https://dannyxie.github.io/2016/04/14/%E4%B8%89%E4%B8%AA%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://dannyxie.github.io/2016/04/14/三个关于数组的小技巧/</id>
    <published>2016-04-14T02:36:07.000Z</published>
    <updated>2017-03-14T02:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-可迭代的空数组"><a href="#1-可迭代的空数组" class="headerlink" title="1.可迭代的空数组"></a>1.可迭代的空数组</h3><p>我们知道，Javacript的所创建的数组如果未被初始化值的话，它是一个稀疏数组(sparse array)，这是什么意思的？我们先看下面的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>); <span class="comment">//[undefined, undefined, undefined, undefined]</span></div></pre></td></tr></table></figure></p>
<p>假设我们要去迭代一个数组，我们会发现，未被初始化值的数组，index实际上访问不到的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.map(<span class="function">(<span class="params">elem, index</span>) =&gt;</span> index); <span class="comment">//  输出:[undefined, undefined, undefined, undefined]</span></div></pre></td></tr></table></figure>
<p>我们分别来看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description" target="_blank" rel="external">Array.prototype.forEach</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description" target="_blank" rel="external">Array.prototype.map</a>的描述，可以留意到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. callback is invoked only for indexes of the array which have assigned values, including undefined. It is not called for missing elements of the array (that is, indexes that have never been set, which have been deleted or which have never been assigned a value).</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forEach() executes the provided callback once for each element present in the array in ascending order. It is not invoked for index properties that have been deleted or are uninitialized (i.e. on sparse arrays).</div></pre></td></tr></table></figure>
<p>对于<code>forEach</code>与<code>map</code>这类方法，如果数组有未被初始化值的index, 默认是不回被遍历的。</p>
<p>那么， 如何创建一个所有值默认可被遍历的数组呢？很简单，我们只需要多加一步操作:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)); <span class="comment">//借助apply给每一个数组的每一个index都赋值</span></div><div class="line">arr.map(<span class="function">(<span class="params">elem, index</span>) =&gt;</span> index); <span class="comment">//这样的话改数组就可以遍历了, 输出 [0, 1, 2, 3]</span></div></pre></td></tr></table></figure></p>
<h3 id="2-利用数组给方法传递空参数"><a href="#2-利用数组给方法传递空参数" class="headerlink" title="2.利用数组给方法传递空参数"></a>2.利用数组给方法传递空参数</h3><p>我们调用方法的时候，有时想对一些参数进行忽略，比如下面的情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method(<span class="string">'parameter1'</span>, , <span class="string">'parameter3'</span>); <span class="comment">//会报错， Uncaught SyntaxError: Unexpected token ,</span></div></pre></td></tr></table></figure></p>
<p>这个时候通常我们的做法是会传一个<code>null</code> 或者 <code>undefined</code> 作为占位<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">method(<span class="string">'parameter1'</span>, <span class="literal">null</span>, <span class="string">'parameter3'</span>)</div><div class="line"><span class="comment">//或者</span></div><div class="line">method(<span class="string">'paramter1'</span>, <span class="literal">undefined</span>, <span class="string">'parameter3'</span>);</div></pre></td></tr></table></figure></p>
<p>我们可以借助ES6的展开语法(…)来辅助传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method(...[&apos;parameter1&apos;, , &apos;paramter3&apos;]); // 大功告成!</div></pre></td></tr></table></figure></p>
<h3 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3. 数组去重"></a>3. 数组去重</h3><p>使用展开符号搭配<code>set</code>进行数组去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const arr = [...new Set([1, 2, 3, 3])];//[1, 2, 3]</div></pre></td></tr></table></figure></p>
<p>参考来源:<br> <a href="http://www.jstips.co/en/javascript/3-array-hacks/" target="_blank" rel="external">3 Array Hacks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-可迭代的空数组&quot;&gt;&lt;a href=&quot;#1-可迭代的空数组&quot; class=&quot;headerlink&quot; title=&quot;1.可迭代的空数组&quot;&gt;&lt;/a&gt;1.可迭代的空数组&lt;/h3&gt;&lt;p&gt;我们知道，Javacript的所创建的数组如果未被初始化值的话，它是一个稀疏数组(s
    
    </summary>
    
    
      <category term="es2015" scheme="https://dannyxie.github.io/tags/es2015/"/>
    
      <category term="javascript" scheme="https://dannyxie.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>webpack使用require.ensure进行代码分割</title>
    <link href="https://dannyxie.github.io/2016/03/16/webpack%E4%BD%BF%E7%94%A8require-ensure%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/"/>
    <id>https://dannyxie.github.io/2016/03/16/webpack使用require-ensure进行代码分割/</id>
    <published>2016-03-15T20:52:13.000Z</published>
    <updated>2017-03-08T20:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><p>实例来自于<a href="https://webpack.js.org/guides/code-splitting-require/" target="_blank" rel="external">webpack</a><br>假定我们有下面的项目结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── dist</div><div class="line">├── js</div><div class="line">│   ├── a.js</div><div class="line">│   ├── b.js</div><div class="line">│   ├── c.js</div><div class="line">│   └── entry.js</div><div class="line">└── webpack.config.js</div></pre></td></tr></table></figure></p>
<p>文件内容<br>entry.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">require(&apos;./a&apos;);</div><div class="line">require.ensure([&apos;./b&apos;], function(require)&#123;</div><div class="line">    require(&apos;./c&apos;);</div><div class="line">    console.log(&apos;done!&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>a.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;***** I AM a *****&apos;);</div></pre></td></tr></table></figure></p>
<p>b.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;***** I AM b *****&apos;);</div></pre></td></tr></table></figure></p>
<p>c.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;***** I AM c *****&apos;);</div></pre></td></tr></table></figure></p>
<p>下面我们看一下<code>webpack.config.js</code>的配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports =  &#123;</div><div class="line">		<span class="attr">entry</span> : <span class="string">'./js/entry.js'</span></div><div class="line">		,</div><div class="line">		<span class="attr">output</span> : &#123;</div><div class="line">			<span class="attr">filename</span> : <span class="string">'bundle.js'</span></div><div class="line">			, <span class="attr">path</span> : path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">			, <span class="attr">publicPath</span>: <span class="string">'./dist/'</span> <span class="comment">//当使用代码分割时，publicPath很重要，它将告诉webpack从哪儿去加载其他打包的文件</span></div><div class="line">			, <span class="attr">pathinfo</span> : <span class="literal">true</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>执行webpack打包之后，我们可以看到结果<br><img src="https://segmentfault.com/img/bVJS9m?w=1352&amp;h=528" alt="执行webpack打包"></p>
<p>我们发现，webpack打包生成了<code>bundle.js</code>以及<code>1.bundle.js</code>两个文件<br>查看文件的内容，我们可以发现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bundle.js</span></div><div class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></div><div class="line"><span class="comment">/******/</span> 	<span class="comment">/*</span></div><div class="line">				webpack 集成的代码，这里略</div><div class="line">			*/</div><div class="line"><span class="comment">/******/</span> 	__webpack_require__.p = <span class="string">"./dist/"</span>; <span class="comment">//按需加载的路径</span></div><div class="line"></div><div class="line"><span class="comment">/******/</span> 	<span class="comment">// Load entry module and return exports</span></div><div class="line"><span class="comment">/******/</span> 	<span class="keyword">return</span> __webpack_require__(<span class="number">0</span>);</div><div class="line"><span class="comment">/******/</span> &#125;)</div><div class="line"><span class="comment">/************************************************************************/</span></div><div class="line"><span class="comment">/******/</span> ([</div><div class="line"><span class="comment">/* 0 */</span></div><div class="line"><span class="comment">/*!*********************!*\</span></div><div class="line">  !*** ./js/entry.js ***!</div><div class="line">  \*********************/</div><div class="line"><span class="comment">/***/</span> <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</div><div class="line"></div><div class="line">	__webpack_require__(<span class="comment">/*! ./a */</span> <span class="number">1</span>)</div><div class="line"></div><div class="line">	__webpack_require__.e<span class="comment">/* nsure */</span>(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">		__webpack_require__(<span class="comment">/*! ./c */</span> <span class="number">3</span>)</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'done!'</span>)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line"><span class="comment">/***/</span> &#125;,</div><div class="line"><span class="comment">/* 1 */</span></div><div class="line"><span class="comment">/*!*****************!*\</span></div><div class="line">  !*** ./js/a.js ***!</div><div class="line">  \*****************/</div><div class="line"><span class="comment">/***/</span> <span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</div><div class="line"></div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'I am a'</span>)</div><div class="line"></div><div class="line"><span class="comment">/***/</span> &#125;</div><div class="line"><span class="comment">/******/</span> ]);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.bundle.js</span></div><div class="line">webpackJsonp([<span class="number">1</span>],[</div><div class="line"><span class="comment">/* 0 */</span>,</div><div class="line"><span class="comment">/* 1 */</span>,</div><div class="line"><span class="comment">/* 2 */</span></div><div class="line"><span class="comment">/*!*****************!*\</span></div><div class="line">  !*** ./js/b.js ***!</div><div class="line">  \*****************/</div><div class="line"><span class="comment">/***/</span> <span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</div><div class="line">	</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'I am b'</span>)</div><div class="line"><span class="comment">/***/</span> &#125;,</div><div class="line"><span class="comment">/* 3 */</span></div><div class="line"><span class="comment">/*!*****************!*\</span></div><div class="line">  !*** ./js/c.js ***!</div><div class="line">  \*****************/</div><div class="line"><span class="comment">/***/</span> <span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'I am c'</span>)</div><div class="line"><span class="comment">/***/</span> &#125;</div><div class="line">]);</div></pre></td></tr></table></figure>
<p><code>a.js</code>的内容被打包到bundle.js之中,而<code>b.js</code>,<code>c.js</code>则位于<code>1.bundle.js</code>中,<code>b.js</code>,<code>c.js</code>从主入口文件中分离了出来，而且只有<code>c.js</code>的内容被执行了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码分割&quot;&gt;&lt;a href=&quot;#代码分割&quot; class=&quot;headerlink&quot; title=&quot;代码分割&quot;&gt;&lt;/a&gt;代码分割&lt;/h2&gt;&lt;p&gt;实例来自于&lt;a href=&quot;https://webpack.js.org/guides/code-splitting-req
    
    </summary>
    
    
      <category term="构建" scheme="https://dannyxie.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>为gulp任务传递参数</title>
    <link href="https://dannyxie.github.io/2016/03/15/%E4%B8%BAgulp%E4%BB%BB%E5%8A%A1%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"/>
    <id>https://dannyxie.github.io/2016/03/15/为gulp任务传递参数/</id>
    <published>2016-03-14T16:26:36.000Z</published>
    <updated>2017-03-14T16:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在web前端的脚手架中，有相当一部分数量的人选择用gulp做为首选的构建工具，但是，我们是没办法向gulp的任务直接传递命令行参数的。<br>我们知道gulp实际上是运行在nodejs中的，那么，我们是可以访问<code>process.argv</code><br>比如命令<code>gulp task1 --a 123 --b &quot;my string&quot; --c</code>, 我们看看<code>process.argv</code>会输出什么<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line"><span class="string">'/usr/bin/nodejs'</span>,</div><div class="line"><span class="string">'/home/user/.node_modules_global/bin/gulp'</span>,</div><div class="line"><span class="string">'task1'</span>,</div><div class="line"><span class="string">'--a'</span>,</div><div class="line"><span class="string">'123'</span>,</div><div class="line"><span class="string">'--b'</span>,</div><div class="line"><span class="string">'my string'</span>,</div><div class="line"><span class="string">'--c'</span></div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>既然可以拿到命令行输入的东西，那么我们就可以自己写一个参数解析的函数啦!<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// fetch command line arguments</span></div><div class="line"><span class="keyword">const</span> arg = (<span class="function"><span class="params">argList</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> arg = &#123;&#125;, a, opt, thisOpt, curOpt;</div><div class="line">  <span class="keyword">for</span> (a = <span class="number">0</span>; a &lt; argList.length; a++) &#123;</div><div class="line"></div><div class="line">    thisOpt = argList[a].trim();</div><div class="line">    opt = thisOpt.replace(<span class="regexp">/^\-+/</span>, <span class="string">''</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (opt === thisOpt) &#123;</div><div class="line"></div><div class="line">      <span class="comment">// argument value</span></div><div class="line">      <span class="keyword">if</span> (curOpt) arg[curOpt] = opt;</div><div class="line">      curOpt = <span class="literal">null</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">      <span class="comment">// argument name</span></div><div class="line">      curOpt = opt;</div><div class="line">      arg[curOpt] = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line"></div><div class="line">&#125;)(process.argv);</div><div class="line"><span class="built_in">console</span>.log(arg) <span class="comment">//&#123; a: '123', b: 'my string', c: true &#125;</span></div></pre></td></tr></table></figure></p>
<p>搞定！</p>
<p>当然，这只是一个简单的实现。<br>我们还可以使用功能更强大的库, 比如TJ大神的<a href="https://github.com/tj/commander" target="_blank" rel="external">commander</a></p>
<p>参考<br><a href="https://www.sitepoint.com/pass-parameters-gulp-tasks/" target="_blank" rel="external">How to Pass Command Line Parameters to Gulp Tasks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在web前端的脚手架中，有相当一部分数量的人选择用gulp做为首选的构建工具，但是，我们是没办法向gulp的任务直接传递命令行参数的。&lt;br&gt;我们知道gulp实际上是运行在nodejs中的，那么，我们是可以访问&lt;code&gt;process.argv&lt;/code&gt;&lt;br&gt;比如
    
    </summary>
    
    
      <category term="构建" scheme="https://dannyxie.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门</title>
    <link href="https://dannyxie.github.io/2016/03/10/webpack%E5%85%A5%E9%97%A8/"/>
    <id>https://dannyxie.github.io/2016/03/10/webpack入门/</id>
    <published>2016-03-10T14:34:59.000Z</published>
    <updated>2017-03-08T20:50:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><p>webpack是一个module bundler，可以将把有依赖关系的各种文件打包成一系列的静态资源</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先我们安装最新版的webpack, 我安装的版本是2.2.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g webpack</div></pre></td></tr></table></figure></p>
<p>下面我们将探讨webpack 2 的使用</p>
<p>我们可以直接在终端中使用webpack，命令如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">webpack &#123;源文件／入口文件&#125; &#123;目标文件&#125;</div><div class="line">webpack --watch //监听模式</div><div class="line">webpack -p //混淆脚本</div></pre></td></tr></table></figure></p>
<p>考虑到随着我们项目复杂度的增高，有可能我们的配置选项也会很多，所以，我们完全可以将配置放到文件中, webpack在执行的时候默认会加载webpack.config.js文件作为配置, 如果我们需要指定配置文件的话，方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --config &#123;配置文件&#125;</div></pre></td></tr></table></figure></p>
<p>下面我们来创建一个简单的项目<br>我们的项目结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── dist</div><div class="line">├── src</div><div class="line">│   └── entry.js</div><div class="line">├── index.html</div><div class="line">└── webpack.config.js</div></pre></td></tr></table></figure></p>
<p>index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;title&gt;&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>src/entry.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.write(&apos;hello world&apos;)</div></pre></td></tr></table></figure></p>
<p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">	entry: &apos;./src/entry.js&apos;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">		filename: &apos;bundle.js&apos;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在终端下运行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --watch</div></pre></td></tr></table></figure></p>
<p>使用<a href="https://www.npmjs.com/package/http-server" target="_blank" rel="external">http-server</a>起一个本地服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http-server -p 8080</div></pre></td></tr></table></figure></p>
<p>可以看到，entry.js的内容被打包到了bundle.js 中<br>这是webpack最简单的应用，下面我们来看看如何使用loader</p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack2中已经集成了<a href="https://webpack.js.org/guides/migrating/#json-loader-is-not-required-anymore" target="_blank" rel="external">json-loader</a>, 所以我们无需安装其他的依赖<br>在src中增加hello.json文件<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"greet"</span> : <span class="string">"hello from json"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>修改<code>entry.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">'./hello.json'</span></div><div class="line"><span class="built_in">document</span>.write(json.greet)</div></pre></td></tr></table></figure></p>
<p>刷新<a href="http://127.0.0.1:8080/" target="_blank" rel="external">http://127.0.0.1:8080/</a><br>可以看到hello.json的结果已经输出到浏览器中</p>
<h4 id="使用其他loader"><a href="#使用其他loader" class="headerlink" title="使用其他loader"></a>使用其他loader</h4><p>如果其他格式的文件，比如css文件我们可以使用相应的loader来解析,安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev style-loader css-loader</div></pre></td></tr></table></figure></p>
<p>修改<code>webpack.config.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">	entry: &apos;./src/entry.js&apos;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">		filename: &apos;bundle.js&apos;</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">		rules: [&#123;</div><div class="line">			test: /\.css$/,</div><div class="line">			use: [&quot;style-loader&quot;, &quot;css-loader&quot;]</div><div class="line">		&#125;]</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>entry.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import &apos;./main.css&apos;</div><div class="line">import json from &apos;./hello.json&apos;</div><div class="line">document.write(json.greet)</div></pre></td></tr></table></figure></p>
<p>可以看到，main.css也经过loader的解析而打包进bundle.js里面了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是webpack&quot;&gt;&lt;a href=&quot;#什么是webpack&quot; class=&quot;headerlink&quot; title=&quot;什么是webpack&quot;&gt;&lt;/a&gt;什么是webpack&lt;/h2&gt;&lt;p&gt;webpack是一个module bundler，可以将把有依赖关系的各种文
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈javascript的原型及原型链</title>
    <link href="https://dannyxie.github.io/2016/03/08/%E6%B5%85%E8%B0%88javascript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://dannyxie.github.io/2016/03/08/浅谈javascript的原型及原型链/</id>
    <published>2016-03-08T14:26:51.000Z</published>
    <updated>2017-03-08T14:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>原型与原型链是javascript里面最最核心的内容，如果不能理解它们之间的存在关系的话，那么我们是不能理解这门语言的。</p>
<p>在JS中，主要有两种创建对象的方法, 分别是对象字面量以及调用构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对象字面量</span></div><div class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用构造函数</span></div><div class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>()</div></pre></td></tr></table></figure></p>
<p>其实上述两种创建对象的方法，本质上是一样的，都是JS引擎调用对象的构造函数来新建出一个对象。构造函数本身也是一个普通的JS函数</p>
<p>下面我们来看一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//每个构造函数JS引擎都会自动添加一个prototype属性，我们称之为原型，这是一个对象</span></div><div class="line"><span class="comment">//每个由构造函数创建的对象都会共享prototype上面的属性与方法</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype) <span class="comment">// 'object'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//我们为Person.prototype添加sayName方法</span></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建实例</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Messi'</span>)</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Suarez'</span>)</div><div class="line"></div><div class="line">person1.sayName() <span class="comment">// 'Messi'</span></div><div class="line">person2.sayName() <span class="comment">// 'Suarez'</span></div><div class="line"></div><div class="line">person1.sayName === person2.sayName <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>我们借助上面的例子来理解构造函数-原型-实例，三者之间的关系，主要有几个基本概念</p>
<ul>
<li>构造函数默认会有一个<code>protoype</code>属性指向它的原型</li>
<li><p>构造函数的原型会有一个<code>consctructor</code>的属性指向构造函数本身, 即</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person.prototype.constructor === Person</div></pre></td></tr></table></figure>
</li>
<li><p>每一个<code>new</code>出来的实例都有一个隐式的<code>__proto__</code>属性，指向它们的构造函数的原型，即</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person1.__proto__ === Person.prototype</div><div class="line">person1.__proto__.constructor === Person</div></pre></td></tr></table></figure>
</li>
</ul>
<p>了解了这些基本概念之后，我们再来看看javascript的一些原生构造函数的关系网，看下列的图</p>
<p><img src="https://i.stack.imgur.com/KFzI3.png" alt="javascript objects treasure map"><br>引自<a href="http://stackoverflow.com/questions/650764/how-does-proto-differ-from-constructor-prototype" target="_blank" rel="external">stackoverflow</a></p>
<p>按照我们上面的理解, Oject本身是一个构造函数，它也是一个对象，那么<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype</div></pre></td></tr></table></figure></p>
<p>为了方便我们记住上图，还有几个需要我们知道的特殊概念：</p>
<ul>
<li><p><code>Function</code>的原型属性与<code>Function</code>的原型指向同一个对象. 即</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.__proto__ == <span class="built_in">Function</span>.prototype</div></pre></td></tr></table></figure>
</li>
<li><p><code>Object.prototype.__proto__ === null</code></p>
</li>
<li><code>typeof Function.prototype === &#39;function&#39;</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型与原型链是javascript里面最最核心的内容，如果不能理解它们之间的存在关系的话，那么我们是不能理解这门语言的。&lt;/p&gt;
&lt;p&gt;在JS中，主要有两种创建对象的方法, 分别是对象字面量以及调用构造函数&lt;br&gt;&lt;figure class=&quot;highlight javas
    
    </summary>
    
    
      <category term="javascript" scheme="https://dannyxie.github.io/tags/javascript/"/>
    
      <category term="prototype" scheme="https://dannyxie.github.io/tags/prototype/"/>
    
  </entry>
  
</feed>
